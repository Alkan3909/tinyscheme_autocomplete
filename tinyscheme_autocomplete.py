import sublime, sublime_plugin

PROCS = [('lambda', '(lambda (${1:args}) ${2:expression})'), ('lambda_block', '(lambda (${1:args})\n\t${2:expressions}\n)'), ('define', '(define (${1:proc}) ${2:expression})'), ('define_variable', '(define ${1:variable} ${2:expression})'), ('define_block', '(define (${1:proc})\n\t${2:expressions}\n)'), ('define_lambda_block', '(define ${1:proc}\n\t(lambda (${2:args})\n\t\t${3:expressions}\n\t)\n)'), ('defined_Q', '(defined? ${1:symbol} ${2:environment_OPTIONAL})'), ('let', '(let ((${1:variable})) ${2:expression})'), ('let_star', '(let* ((${1:variable_a}) (${2:variable_b})) ${3:expression})'), ('let_block', '(let\n\t(\n\t\t(${1:variable})\n\t)\n\t\t${2:expressions}\n)'), ('let_star_block', '(let*\n\t(\n\t\t(${1:variable_a})\n\t\t(${2:variable_b})\n\t)\n\t\t${3:expressions}\n)'), ('let_named_block', '(let ${1:iter}\n\t(\n\t\t(${2:args})\n\t)\n\t\t${3:test___expressions___iter_call}\n)'), ('let_named_null_test_block', '(let iter\n\t(\n\t\t(lst ${1:list})\n\t)\n\t\t(unless (null? lst)\n\t\t\t${2:expressions}\n\t\t\t(iter (cdr lst))\n\t\t)\n)'), ('let_named_index_test_block', '(let iter\n\t(\n\t\t(i ${1:0})\n\t)\n\t\t(when (< i ${2:len})\n\t\t\t${3:expressions}\n\t\t\t(iter (+ i ${4:1}))\n\t\t)\n)'), ('letrec_block', '(letrec\n\t(\n\t\t(${1:iter}\n\t\t\t(lambda (${2:args_declared})\n\t\t\t\t${3:test___expressions___iter_call}\n\t\t\t)\n\t\t)\n\t)\n\t\t(${1:iter} ${4:args_passed})\n)'), ('letrec_null_test_block', '(letrec\n\t(\n\t\t(iter\n\t\t\t(lambda (lst)\n\t\t\t\t(unless (null? lst)\n\t\t\t\t\t${1:expressions}\n\t\t\t\t\t(iter (cdr lst))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t\t(iter ${2:the_lst})\n)'), ('letrec_index_test_block', '(letrec\n\t(\n\t\t(iter\n\t\t\t(lambda (i)\n\t\t\t\t(when (< i ${1:len})\n\t\t\t\t\t${2:expressions}\n\t\t\t\t\t(iter (+ i ${3:1}))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t\t(iter ${4:0})\n)'), ('proc', '(proc ${1:expression})'), ('loop', '(loop ${1:expression})'), ('iter', '(iter ${1:expression})'), ('do', '(do ((${1:var_declr} ${2:var_incr})) (${3:test_exit} ${4:expression_conditional_exit}) ${5:expression_body})'), ('do_block', '(do\n\t(\n\t\t(${1:var_declr} ${2:var_incr})\n\t)\n\t(${3:test_exit} ${4:expression_conditional_exit})\n\t${5:expressions_body}\n)'), ('do_null_test_block', '(do\n\t(\n\t\t(lst ${1:list} (cdr lst))\n\t)\n\t((null? lst) ${2:expression_conditional_exit})\n\t${3:expressions_body}\n)'), ('do_index_test_block', '(do\n\t(\n\t\t(i ${1:0} (+ i ${2:1}))\n\t)\n\t((>= i ${3:len}) ${4:expression_conditional_exit})\n\t${5:expressions_body}\n)'), ('car', '(car ${1:list})'), ('caar', '(caar ${1:list})'), ('caaar', '(caaar ${1:list})'), ('caaaar', '(caaaar ${1:list})'), ('cdr', '(cdr ${1:list})'), ('cddr', '(cddr ${1:list})'), ('cdddr', '(cdddr ${1:list})'), ('cddddr', '(cddddr ${1:list})'), ('cadr', '(cadr ${1:list})'), ('caadr', '(caadr ${1:list})'), ('caaadr', '(caaadr ${1:list})'), ('cdar', '(cdar ${1:list})'), ('cdaar', '(cdaar ${1:list})'), ('cdaaar', '(cdaaar ${1:list})'), ('cddar', '(cddar ${1:list})'), ('cdddar', '(cdddar ${1:list})'), ('cddaar', '(cddaar ${1:list})'), ('cdadr', '(cdadr ${1:list})'), ('cadar', '(cadar ${1:list})'), ('cadaar', '(cadaar ${1:list})'), ('caadar', '(caadar ${1:list})'), ('caaddr', '(caaddr ${1:list})'), ('caddr', '(caddr ${1:list})'), ('cadddr', '(cadddr ${1:list})'), ('caddar', '(caddar ${1:list})'), ('cadadr', '(cadadr ${1:list})'), ('cdadar', '(cdadar ${1:list})'), ('cdaddr', '(cdaddr ${1:list})'), ('cdaadr', '(cdaadr ${1:list})'), ('cddadr', '(cddadr ${1:list})'), ('vector', '(vector ${1:element_a} ${2:element_b} ${3:element_n})'), ('make_vector', '(make-vector ${1:length_number} ${2:element_OPTIONAL})'), ('vector_fill', '(vector-fill! ${1:vector} ${2:element})'), ('vector_set', '(vector-set! ${1:vector} ${2:index} ${3:value})'), ('vector_ref', '(vector-ref ${1:vector} ${2:index})'), ('vector_length', '(vector-length ${1:vector})'), ('vector_to_list', '(vector->list ${1:vector})'), ('vector_Q', '(vector? ${1:vector})'), ('vector_equal_Q', '(vector-equal? ${1:vector_a} ${2:vector_b})'), ('display', '(display ${1:string})'), ('display_newline', '(display "${1:string}\\\\n")'), ('display_block', '(display\n\t${1:string}\n)'), ('write', '(write ${1:string})'), ('write_newline', '(write "${1:string}\\\\n")'), ('write_block', '(write\n\t${1:string}\n)'), ('write_char', '(write-char ${1:char})'), ('newline', '(newline)'), ('error', '(error ${1:string})'), ('current_input_port', '(current-input-port)'), ('current_output_port', '(current-output-port)'), ('port_Q', '(port? ${1:port})'), ('input_port_Q', '(input-port? ${1:port})'), ('output_port_Q', '(output-port? ${1:port})'), ('input_output_port_Q', '(input-output-port? ${1:port})'), ('close_port', '(close-port ${1:port})'), ('open_input_file', '(open-input-file ${1:path_string})'), ('open_input_file_block', '(open-input-file\n\t${1:path_string}\n)'), ('open_input_string', '(open-input-string ${1:path_string})'), ('open_input_output_string', '(open-input-output-string ${1:path_string})'), ('open_input_output_file', '(open-input-output-file ${1:path_string})'), ('open_input_output_file_block', '(open-input-output-file\n\t${1:path_string}\n)'), ('set_input_port', '(set-input-port ${1:port})'), ('set_output_port', '(set-output-port ${1:port})'), ('close_input_port', '(close-input-port ${1:input_file_port})'), ('eof_object_Q', '(eof-object? ${1:input_file})'), ('char_ready_Q', '(char-ready? ${1:input_file_port_OPTIONAL})'), ('read_char', '(read-char ${1:input_file_port})'), ('peek_char', '(peek-char ${1:input_file_port})'), ('read', '(read ${1:input_file_or_script_etc_port})'), ('open_output_file', '(open-output-file ${1:path_string})'), ('open_output_file_block', '(open-output-file\n\t${1:path_string}\n)'), ('open_output_string', '(open-output-string ${1:path_string})'), ('get_output_string', '(get-output-string ${1:output-port})'), ('close_output_port', '(close-output-port ${1:output_file_port})'), ('with_input_from_file', '(with-input-from-file ${1:path_string} ${2:proc})'), ('with_input_from_file_block', '(with-input-from-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('with_output_to_file', '(with-output-to-file ${1:path_string} ${2:proc})'), ('with_output_to_file_block', '(with-output-to-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('with_input_output_from_to_files', '(with-input-output-from-to-files ${1:input_path_string} ${2:output_path_string} ${3:proc})'), ('with_input_output_from_to_files_block', '(with-input-output-from-to-files\n\t${1:input_path_string}\n\t${2:output_path_string}\n\t${3:proc}\n)'), ('call_with_input_file', '(call-with-input-file ${1:path_string} ${2:proc})'), ('call_with_input_file_block', '(call-with-input-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('call_with_output_file', '(call-with-output-file ${1:path_string} ${2:proc})'), ('call_with_output_file_block', '(call-with-output-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('if', '(if ${1:test} ${2:expression_true} ${3:expression_false})'), ('if_block', '(if ${1:test}\n\t${2:expression_true}\n\t${3:expression_false}\n)'), ('if_begin_block', '(if ${1:test}\n\t(begin\n\t\t${2:expressions_true}\n\t)\n\t(begin\n\t\t${3:expressions_false}\n\t)\n)'), ('if_begin_true_block', '(if ${1:test}\n\t(begin\n\t\t${2:expressions_true}\n\t)\n)'), ('when', '(when ${1:test} ${2:expression})'), ('when_block', '(when ${1:test}\n\t${2:expressions}\n)'), ('unless', '(unless ${1:test} ${2:expression})'), ('unless_block', '(unless ${1:test}\n\t${2:expressions}\n)'), ('cond', '(cond (${1:test} ${2:expression}) (else ${3:expression}))'), ('cond_block', '(cond\n\t(${1:test}\n\t\t${2:expressions}\n\t)\n\t(else\n\t\t${3:expressions}\n\t)\n)'), ('case', '(case ${1:test} ((${2:clause_a}) ${3:expression}) ((${4:clause_b}) ${5:expression}) ((${6:clause_n}) ${7:expression}))'), ('case_block', '(case ${1:test}\n\t((${2:clause_a})\n\t\t${3:expressions}\n\t)\n\t((${4:clause_b})\n\t\t${5:expressions}\n\t)\n\t((${6:clause_n})\n\t\t${7:expressions}\n\t)\n)'), ('number_to_string', '(number->string ${1:number})'), ('set', '(set! ${1:variable} ${2:value})'), ('set_car', '(set-car! ${1:list} ${2:value})'), ('set_cdr', '(set-cdr! ${1:list} ${2:value})'), ('quote', '(quote ${1:expression})'), ('quasiquote', '(quasiquote ${1:expression})'), ('not', '(not ${1:expression})'), ('null_Q', '(null? ${1:list})'), ('append', '(append ${1:list_a} ${2:list_b})'), ('append_block', '(append\n\t${1:list_a}\n\t${2:list_b}\n)'), ('cons', '(cons ${1:element} ${2:list})'), ('acons', '(acons ${1:expression_a} ${2:expression_b} ${3:expression_c})'), ('acons_block', '(acons\n\t${1:expression_a}\n\t${2:expression_b}\n\t${3:expression_c}\n)'), ('pair_Q', '(pair? ${1:pair_list})'), ('char_Q', '(char? ${1:char})'), ('char_cmp_Q', '(char-cmp? ${1:comparison_proc} ${2:char_a} ${3:char_b})'), ('char_ci_cmp_Q', '(char_ci-cmp? ${1:comparison_proc} ${2:char_a} ${3:char_b})'), ('char_equal_Q', '(char=? ${1:char_a} ${2:char_b})'), ('char_less_than_Q', '(char<? ${1:char_a} ${2:char_b})'), ('char_greater_than_Q', '(char>? ${1:char_a} ${2:char_b})'), ('char_less_than_equal_Q', '(char<=? ${1:char_a} ${2:char_b})'), ('char_greater_than_equal_Q', '(char>=? ${1:char_a} ${2:char_b})'), ('char_ci_equal_Q', '(char-ci=? ${1:char_a} ${2:char_b})'), ('char_ci_less_than_Q', '(char-ci<? ${1:char_a} ${2:char_b})'), ('char_ci_greater_than_Q', '(char-ci>? ${1:char_a} ${2:char_b})'), ('char_ci_less_than_equal_Q', '(char-ci<=? ${1:char_a} ${2:char_b})'), ('char_ci_greater_than_equal_Q', '(char-ci>=? ${1:char_a} ${2:char_b})'), ('string_cmp_Q', '(string-cmp? ${1:char-cmp} ${2:comparison_proc} ${3:string_a} ${4:string_b})'), ('string_cmp_Q_block', '(string-cmp?\n\t${1:char-cmp}\n\t${2:comparison_proc}\n\t${3:string_a}\n\t${4:string_b}\n)'), ('char_to_integer', '(char->integer ${1:char})'), ('integer_to_char', '(integer->char ${1:integer})'), ('atom_Q', '(atom? ${1:expression})'), ('atom_to_string', '(atom->string ${1:atom})'), ('string', '(string ${1:char_a} ${2:char_b} ${3:char_n})'), ('string_Q', '(string? ${1:string})'), ('string_length', '(string-length ${1:string})'), ('string_to_number', '(string->number ${1:string})'), ('string_to_atom', '(string->atom ${1:string})'), ('string_anyatom', '(string->anyatom ${1:string} ${2:proc})'), ('anyatom_string', '(anyatom->string ${1:atom} ${2:proc})'), ('string_append', '(string-append ${1:string_a} ${2:string_b})'), ('string_append_block', '(string-append\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_equal_Q', '(string=? ${1:string_a} ${2:string_b})'), ('string_equal_Q_block', '(string=?\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_less_than_Q', '(string<? ${1:string_a} ${2:string_b})'), ('string_greater_than_Q', '(string>? ${1:string_a} ${2:string_b})'), ('string_less_than_equal_Q', '(string<=? ${1:string_a} ${2:string_b})'), ('string_greater_than_equal_Q', '(string>=? ${1:string_a} ${2:string_b})'), ('string_ci_equal_Q', '(string-ci=? ${1:string_a} ${2:string_b})'), ('string_ci_equal_Q_block', '(string-ci=?\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_ci_less_than_Q', '(string-ci<? ${1:string_a} ${2:string_b})'), ('string_ci_greater_than_Q', '(string-ci>? ${1:string_a} ${2:string_b})'), ('string_ci_less_than_equal_Q', '(string-ci<=? ${1:string_a} ${2:string_b})'), ('string_ci_greater_than_equal_Q', '(string-ci>=? ${1:string_a} ${2:string_b})'), ('symbol_to_string', '(symbol->string ${1:symbol})'), ('string_to_symbol', '(string->symbol ${1:string})'), ('string_to_list', '(string->list ${1:string})'), ('string_set', '(string-set! ${1:variable} ${2:index} ${3:char})'), ('make_string', '(make-string ${1:length_number} ${2:char_OPTIONAL})'), ('string_copy', '(string-copy ${1:variable})'), ('string_fill', '(string-fill! ${1:variable_string_mutable} ${2:char})'), ('string_ref', '(string-ref ${1:string} ${2:index})'), ('substring', '(substring ${1:string} ${2:start_index} ${3:end_index})'), ('symbol_Q', '(symbol? ${1:symbol})'), ('list_Q', '(list? ${1:list})'), ('list_reference', '(list-ref ${1:list} ${2:index})'), ('length', '(length ${1:list})'), ('list_tail', '(list-tail ${1:list} ${2:no_of_elements_tobe_removed_from_head})'), ('last_pair', '(last-pair ${1:list})'), ('reverse', '(reverse ${1:list})'), ('list_to_string', '(list->string ${1:list})'), ('list_to_vector', '(list->vector ${1:list})'), ('member', '(member ${1:element} ${2:list})'), ('memq', '(memq ${1:element} ${2:list})'), ('memv', '(memv ${1:element} ${2:list})'), ('generic_member', '(generic-member ${1:comparison_proc} ${2:element} ${3:list})'), ('generic_member_block', '(generic-member\n\t${1:comparison_proc}\n\t${2:element}\n\t${3:list}\n)'), ('assoc', '(assoc ${1:element} ${2:list_of_pairs})'), ('assq', '(assq ${1:element} ${2:list_of_pairs})'), ('assv', '(assv ${1:element} ${2:list_of_pairs})'), ('generic_assoc', '(generic-assoc ${1:comparison_proc} ${2:element} ${3:list_of_pairs})'), ('generic_assoc_block', '(generic-assoc\n\t${1:comparison_proc}\n\t${2:element}\n\t${3:list_of_pairs}\n)'), ('map', '(map ${1:proc} ${2:list})'), ('map_block', '(map\n\t${1:proc}\n\t${2:list}\n)'), ('apply', '(apply ${1:proc} ${2:list})'), ('apply_block', '(apply\n\t${1:proc}\n\t${2:list}\n)'), ('for_each', '(for-each ${1:proc} ${2:list})'), ('for_each_block', '(for-each\n\t${1:proc}\n\t${2:list}\n)'), ('begin', '(begin ${1:expression_a} ${2:expression_b} ${3:expression_n})'), ('begin_block', '(begin\n\t${1:expressions}\n)'), ('eq_Q', '(eq? ${1:expression_a} ${2:expression_b})'), ('eqv_Q', '(eqv? ${1:expression_a} ${2:expression_b})'), ('equal_Q', '(equal? ${1:expression_a} ${2:expression_b})'), ('and', '(and ${1:expression_a} ${2:expression_b})'), ('and_block', '(and\n\t${1:expression_a}\n\t${2:expression_b}\n)'), ('or', '(or ${1:expression_a} ${2:expression_b})'), ('or_block', '(or\n\t${1:expression_a}\n\t${2:expression_b}\n)'), ('equal', '(= ${1:number_a} ${2:number_b})'), ('equal_block', '(=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('not_equal', '(<> ${1:number_a} ${2:number_b})'), ('not_equal_block', '(<>\n\t${1:number_a}\n\t${2:number_b}\n)'), ('less', '(< ${1:number_a} ${2:number_b})'), ('less_block', '(<\n\t${1:number_a}\n\t${2:number_b}\n)'), ('less_than_equal', '(<= ${1:number_a} ${2:number_b})'), ('less_than_equal_block', '(<=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('greater', '(> ${1:number_a} ${2:number_b})'), ('greater_block', '(>\n\t${1:number_a}\n\t${2:number_b}\n)'), ('greater_than_equal', '(>= ${1:number_a} ${2:number_b})'), ('greater_than_equal_block', '(>=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('plus', '(+ ${1:number_a} ${2:number_b})'), ('minus', '(- ${1:big_number_a} ${2:small_number_b})'), ('multiply', '(* ${1:number_a} ${2:number_b})'), ('devide', '(/ ${1:number_a} ${2:number_b})'), ('zero_Q', '(zero? ${1:number})'), ('integer_Q', '(integer? ${1:number})'), ('exact_Q', '(exact? ${1:number})'), ('inexact_Q', '(inexact? ${1:number})'), ('complex_Q', '(complex? ${1:number})'), ('number_Q', '(number? ${1:number})'), ('rational_Q', '(rational? ${1:number})'), ('real_Q', '(real? ${1:number})'), ('even_Q', '(even? ${1:number})'), ('odd_Q', '(odd? ${1:number})'), ('positive_Q', '(positive? ${1:number})'), ('negative_Q', '(negative? ${1:number})'), ('succ', '(succ ${1:number})'), ('pred', '(pred ${1:number})'), ('abs', '(abs ${1:number})'), ('exact_to_inexact', '(exact->inexact ${1:number})'), ('inexact_to_exact', '(inexact->exact ${1:number})'), ('exp', '(exp ${1:number})'), ('expt', '(expt ${1:number} ${2:number})'), ('sqrt', '(sqrt ${1:number})'), ('log', '(log ${1:number})'), ('sin', '(sin ${1:number})'), ('cos', '(cos ${1:number})'), ('tan', '(tan ${1:number})'), ('asin', '(asin ${1:number})'), ('acos', '(acos ${1:number})'), ('atan', '(atan ${1:number})'), ('round', '(round ${1:number})'), ('floor', '(floor ${1:number})'), ('ceiling', '(ceiling ${1:number})'), ('trunc', '(trunc ${1:number})'), ('quotient', '(quotient ${1:number} ${2:number})'), ('remainder', '(remainder ${1:number} ${2:number})'), ('modulo', '(modulo ${1:number} ${2:number})'), ('gcd', '(gcd ${1:number_a} ${2:number_b} ${3:number_n})'), ('lcm', '(lcm ${1:number_a} ${2:number_b} ${3:number_n})'), ('max', '(max ${1:number_a} ${2:number_b} ${3:number_n})'), ('min', '(min ${1:number_a} ${2:number_b} ${3:number_n})'), ('unzip1_with_cdr', '(unzip1-with-cdr ${1:list_a} ${2:list_b} ${3:list_n})'), ('unzip1_with_cdr_iterative', '(unzip1-with-cdr-iterative ${1:multiple_lists} ${2:cars} ${3:cdrs})'), ('head', '(head ${1:stream})'), ('tail', '(tail ${1:stream})'), ('shared_tail', '(shared-tail ${1:list_a} ${2:list_b})'), ('eval', '(eval ${1:expression} ${2:environment_OPTIONAL})'), ('make_environment', '(make-environment ${1:expression})'), ('current_environment', '(current-environment)'), ('call_with_current_continuation', '(call-with-current-continuation ${1:proc})'), ('call_cc', '(call/c ${1:proc})'), ('define_with_return', '(define-with-return ${1:expression})'), ('define_with_return_block', '(define-with-return\n\t${1:expression}\n)'), ('random_next', '(random-next)'), ('cond_expand', '(cond-expand ${1:list})'), ('cond_expand_runtime', '(cond-expand-runtime ${1:list})'), ('cond_eval', '(cond-eval ${1:condition})'), ('cond_eval_and', '(cond-eval-and ${1:cond_list})'), ('cond_eval_or', '(cond-eval-or ${1:cond_list})'), ('eval_polymorphic', '(eval-polymorphic ${1:expressions})'), ('gensym', '(gensym)'), ('gc', '(gc)'), ('gc_verbose', '(gc-verbose ${1:bool})'), ('quit', '(quit ${1:number_OPTIONAL})'), ('tracing', '(tracing ${1:0_OFF_1_ON})'), ('boolean_Q', '(boolean? ${1:boolean})'), ('procedure_Q', '(procedure? ${1:proc})'), ('closure_Q', '(closure? ${1:proc})'), ('macro_Q', '(macro? ${1:expression})'), ('macro_expand', '(macro-expand ${1:macro_name_within_literal_list_with_args})'), ('macro', '(macro (${1:identifier} form) ${2:expression})'), ('macro_block', '(macro (${1:identifier} form)\n\t${2:expressions}\n)'), ('define_macro', '(define-macro ${1:expressions})'), ('define_macro_block', '(define-macro\n\t${1:expressions}\n)'), ('environment_Q', '(environment? ${1:expression})'), ('force', '(force ${1:list})'), ('dynamic_wind', '(dynamic-wind ${1:before} ${2:thunk} ${3:after})'), ('dynamic_wind_block', '(dynamic-wind\n\t${1:before}\n\t${2:thunk}\n\t${3:after}\n)'), ('oblist', '(oblist)'), ('new_segment', '(new-segment ${1:number})'), ('get_closure_code', '(get-closure-code ${1:closure_name})'), ('make_closure', '(make-closure ${1:code} ${2:environment})'), ('foldr', '(foldr ${1:proc} ${2:expression} ${3:list})'), ('foldr_block', '(foldr\n\t${1:proc}\n\t${2:expression}\n\t${3:list}\n)'), ('catch', '(catch ${1:expression_exception_raised} ${2:expression_exception_tested})'), ('catch_block', '(catch\n\t${1:expression_exception_raised}\n\t${2:expression_exception_tested}\n)'), ('throw', '(throw ${1:string})'), ('load', '(load ${1:path_scheme_script_string})'), ('list_literal', "'(${1:element_a} ${2:element_b} ${3:element_n})"), ('vector_literal', '#(${1:element_a} ${2:element_b} ${3:element_n})'), ('list', '(list ${1:element_a} ${2:element_b} ${3:element_n})')]

class TinySchemeAutoComplete(sublime_plugin.EventListener):

  def on_query_completions(self, view, prefix, locations):
    return PROCS if view.match_selector(locations[0] - len(prefix), 'source.lisp - string') else None

# Copyright (c) 2020 civAnimal ... Email: civanimal@gmail.com ... Twitter: civAnimal
# Released under ... GNU General Public License (v3)
