import sublime_plugin

PROCS = [('lambda\tFun', '(lambda (${1:args}) ${2:expression})'), ('lambda_block\tFun', '(lambda (${1:args})\n\t${2:expressions}\n)'), ('define\tFun', '(define (${1:proc}) ${2:expression})'), ('define_variable\tFun', '(define ${1:variable} ${2:expression})'), ('define_block\tFun', '(define (${1:proc})\n\t${2:expressions}\n)'), ('define_lambda_block\tFun', '(define ${1:proc}\n\t(lambda (${2:args})\n\t\t${3:expressions}\n\t)\n)'), ('defined_Q\tFun', '(defined? ${1:symbol} ${2:environment_OPTIONAL})'), ('let\tFun', '(let ((${1:variable})) ${2:expression})'), ('let_star\tFun', '(let* ((${1:variable_a}) (${2:variable_b})) ${3:expression})'), ('let_block\tFun', '(let\n\t(\n\t\t(${1:variable})\n\t)\n\t\t${2:expressions}\n)'), ('let_star_block\tFun', '(let*\n\t(\n\t\t(${1:variable_a})\n\t\t(${2:variable_b})\n\t)\n\t\t${3:expressions}\n)'), ('let_named_block\tFun', '(let ${1:iter}\n\t(\n\t\t(${2:args})\n\t)\n\t\t${3:test___expressions___iter_call}\n)'), ('let_named_null_test_block\tFun', '(let ${1:iter}\n\t(\n\t\t(${2:lst} ${3:list})\n\t)\n\t\t(unless (null? ${2:lst})\n\t\t\t${4:expressions}\n\t\t\t(${1:iter} (cdr ${2:lst}))\n\t\t)\n)'), ('let_named_index_test_block\tFun', '(let ${1:iter}\n\t(\n\t\t(i ${2:0})\n\t)\n\t\t(when (< i ${3:len})\n\t\t\t${4:expressions}\n\t\t\t(${1:iter} (+ i ${5:1}))\n\t\t)\n)'), ('letrec_block\tFun', '(letrec\n\t(\n\t\t(${1:iter}\n\t\t\t(lambda (${2:args_declared})\n\t\t\t\t${3:test___expressions___iter_call}\n\t\t\t)\n\t\t)\n\t)\n\t\t(${1:iter} ${4:args_passed})\n)'), ('letrec_null_test_block\tFun', '(letrec\n\t(\n\t\t(${1:iter}\n\t\t\t(lambda (${2:lst})\n\t\t\t\t(unless (null? ${2:lst})\n\t\t\t\t\t${3:expressions}\n\t\t\t\t\t(${1:iter} (cdr ${2:lst}))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t\t(${1:iter} ${4:the_lst})\n)'), ('letrec_index_test_block\tFun', '(letrec\n\t(\n\t\t(${1:iter}\n\t\t\t(lambda (i)\n\t\t\t\t(when (< i ${2:len})\n\t\t\t\t\t${3:expressions}\n\t\t\t\t\t(${1:iter} (+ i ${4:1}))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t\t(${1:iter} ${5:0})\n)'), ('proc\tFun', '(proc ${1:expression})'), ('loop\tFun', '(loop ${1:expression})'), ('iter\tFun', '(iter ${1:expression})'), ('do\tFun', '(do ((${1:var_declr} ${2:var_incr})) (${3:test_exit} ${4:expression_conditional_exit}) ${5:expression_body})'), ('do_block\tFun', '(do\n\t(\n\t\t(${1:var_declr} ${2:var_incr})\n\t)\n\t(${3:test_exit} ${4:expression_conditional_exit})\n\t${5:expressions_body}\n)'), ('do_null_test_block\tFun', '(do\n\t(\n\t\t(${1:lst} ${2:list} (cdr ${1:lst}))\n\t)\n\t((null? ${1:lst}) ${3:expression_conditional_exit})\n\t${4:expressions_body}\n)'), ('do_index_test_block\tFun', '(do\n\t(\n\t\t(i ${1:0} (+ i ${2:1}))\n\t)\n\t((>= i ${3:len}) ${4:expression_conditional_exit})\n\t${5:expressions_body}\n)'), ('car\tFun', '(car ${1:list})'), ('caar\tFun', '(caar ${1:list})'), ('caaar\tFun', '(caaar ${1:list})'), ('caaaar\tFun', '(caaaar ${1:list})'), ('cdr\tFun', '(cdr ${1:list})'), ('cddr\tFun', '(cddr ${1:list})'), ('cdddr\tFun', '(cdddr ${1:list})'), ('cddddr\tFun', '(cddddr ${1:list})'), ('cadr\tFun', '(cadr ${1:list})'), ('caadr\tFun', '(caadr ${1:list})'), ('caaadr\tFun', '(caaadr ${1:list})'), ('cdar\tFun', '(cdar ${1:list})'), ('cdaar\tFun', '(cdaar ${1:list})'), ('cdaaar\tFun', '(cdaaar ${1:list})'), ('cddar\tFun', '(cddar ${1:list})'), ('cdddar\tFun', '(cdddar ${1:list})'), ('cddaar\tFun', '(cddaar ${1:list})'), ('cdadr\tFun', '(cdadr ${1:list})'), ('cadar\tFun', '(cadar ${1:list})'), ('cadaar\tFun', '(cadaar ${1:list})'), ('caadar\tFun', '(caadar ${1:list})'), ('caaddr\tFun', '(caaddr ${1:list})'), ('caddr\tFun', '(caddr ${1:list})'), ('cadddr\tFun', '(cadddr ${1:list})'), ('caddar\tFun', '(caddar ${1:list})'), ('cadadr\tFun', '(cadadr ${1:list})'), ('cdadar\tFun', '(cdadar ${1:list})'), ('cdaddr\tFun', '(cdaddr ${1:list})'), ('cdaadr\tFun', '(cdaadr ${1:list})'), ('cddadr\tFun', '(cddadr ${1:list})'), ('vector\tFun', '(vector ${1:element_a} ${2:element_b} ${3:element_n})'), ('make_vector\tFun', '(make-vector ${1:length_number} ${2:element_OPTIONAL})'), ('vector_fill\tFun', '(vector-fill! ${1:vector} ${2:element})'), ('vector_set\tFun', '(vector-set! ${1:vector} ${2:index} ${3:value})'), ('vector_ref\tFun', '(vector-ref ${1:vector} ${2:index})'), ('vector_length\tFun', '(vector-length ${1:vector})'), ('vector_to_list\tFun', '(vector->list ${1:vector})'), ('vector_Q\tFun', '(vector? ${1:vector})'), ('vector_equal_Q\tFun', '(vector-equal? ${1:vector_a} ${2:vector_b})'), ('display\tFun', '(display ${1:string})'), ('display_newline\tFun', '(display "${1:string}\\\\n")'), ('display_block\tFun', '(display\n\t${1:string}\n)'), ('write\tFun', '(write ${1:string})'), ('write_newline\tFun', '(write "${1:string}\\\\n")'), ('write_block\tFun', '(write\n\t${1:string}\n)'), ('write_char\tFun', '(write-char ${1:char})'), ('newline\tFun', '(newline)'), ('error\tFun', '(error ${1:string})'), ('current_input_port\tFun', '(current-input-port)'), ('current_output_port\tFun', '(current-output-port)'), ('port_Q\tFun', '(port? ${1:port})'), ('input_port_Q\tFun', '(input-port? ${1:port})'), ('output_port_Q\tFun', '(output-port? ${1:port})'), ('input_output_port_Q\tFun', '(input-output-port? ${1:port})'), ('close_port\tFun', '(close-port ${1:port})'), ('open_input_file\tFun', '(open-input-file ${1:path_string})'), ('open_input_file_block\tFun', '(open-input-file\n\t${1:path_string}\n)'), ('open_input_string\tFun', '(open-input-string ${1:path_string})'), ('open_input_output_string\tFun', '(open-input-output-string ${1:path_string})'), ('open_input_output_file\tFun', '(open-input-output-file ${1:path_string})'), ('open_input_output_file_block\tFun', '(open-input-output-file\n\t${1:path_string}\n)'), ('set_input_port\tFun', '(set-input-port ${1:port})'), ('set_output_port\tFun', '(set-output-port ${1:port})'), ('close_input_port\tFun', '(close-input-port ${1:input_file_port})'), ('eof_object_Q\tFun', '(eof-object? ${1:input_file})'), ('char_ready_Q\tFun', '(char-ready? ${1:input_file_port_OPTIONAL})'), ('read_char\tFun', '(read-char ${1:input_file_port})'), ('peek_char\tFun', '(peek-char ${1:input_file_port})'), ('read\tFun', '(read ${1:input_file_or_script_etc_port})'), ('open_output_file\tFun', '(open-output-file ${1:path_string})'), ('open_output_file_block\tFun', '(open-output-file\n\t${1:path_string}\n)'), ('open_output_string\tFun', '(open-output-string ${1:path_string})'), ('get_output_string\tFun', '(get-output-string ${1:output-port})'), ('close_output_port\tFun', '(close-output-port ${1:output_file_port})'), ('with_input_from_file\tFun', '(with-input-from-file ${1:path_string} ${2:proc})'), ('with_input_from_file_block\tFun', '(with-input-from-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('with_output_to_file\tFun', '(with-output-to-file ${1:path_string} ${2:proc})'), ('with_output_to_file_block\tFun', '(with-output-to-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('with_input_output_from_to_files\tFun', '(with-input-output-from-to-files ${1:input_path_string} ${2:output_path_string} ${3:proc})'), ('with_input_output_from_to_files_block\tFun', '(with-input-output-from-to-files\n\t${1:input_path_string}\n\t${2:output_path_string}\n\t${3:proc}\n)'), ('call_with_input_file\tFun', '(call-with-input-file ${1:path_string} ${2:proc})'), ('call_with_input_file_block\tFun', '(call-with-input-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('call_with_output_file\tFun', '(call-with-output-file ${1:path_string} ${2:proc})'), ('call_with_output_file_block\tFun', '(call-with-output-file\n\t${1:path_string}\n\t${2:proc}\n)'), ('if\tFun', '(if ${1:test} ${2:expression_true} ${3:expression_false})'), ('if_block\tFun', '(if ${1:test}\n\t${2:expression_true}\n\t${3:expression_false}\n)'), ('if_begin_block\tFun', '(if ${1:test}\n\t(begin\n\t\t${2:expressions_true}\n\t)\n\t(begin\n\t\t${3:expressions_false}\n\t)\n)'), ('if_begin_true_block\tFun', '(if ${1:test}\n\t(begin\n\t\t${2:expressions_true}\n\t)\n)'), ('when\tFun', '(when ${1:test} ${2:expression})'), ('when_block\tFun', '(when ${1:test}\n\t${2:expressions}\n)'), ('unless\tFun', '(unless ${1:test} ${2:expression})'), ('unless_block\tFun', '(unless ${1:test}\n\t${2:expressions}\n)'), ('cond\tFun', '(cond (${1:test} ${2:expression_true}) (else ${3:expression_false}))'), ('cond_block\tFun', '(cond\n\t(${1:test}\n\t\t${2:expressions_true}\n\t)\n\t(else\n\t\t${3:expressions_false}\n\t)\n)'), ('case\tFun', '(case ${1:test} ((${2:clause_a}) ${3:expression_a}) ((${4:clause_b}) ${5:expression_b}) ((${6:clause_n}) ${7:expression_n}))'), ('case_block\tFun', '(case ${1:test}\n\t((${2:clause_a})\n\t\t${3:expressions_a}\n\t)\n\t((${4:clause_b})\n\t\t${5:expressions_b}\n\t)\n\t((${6:clause_n})\n\t\t${7:expressions_n}\n\t)\n)'), ('number_to_string\tFun', '(number->string ${1:number})'), ('set\tFun', '(set! ${1:variable} ${2:value})'), ('set_car\tFun', '(set-car! ${1:list} ${2:value})'), ('set_cdr\tFun', '(set-cdr! ${1:list} ${2:value})'), ('quote\tFun', '(quote ${1:expression})'), ('quasiquote\tFun', '(quasiquote ${1:expression})'), ('not\tFun', '(not ${1:expression})'), ('null_Q\tFun', '(null? ${1:list})'), ('append\tFun', '(append ${1:list_a} ${2:list_b})'), ('append_block\tFun', '(append\n\t${1:list_a}\n\t${2:list_b}\n)'), ('cons\tFun', '(cons ${1:element} ${2:list})'), ('acons\tFun', '(acons ${1:expression_a} ${2:expression_b} ${3:expression_c})'), ('acons_block\tFun', '(acons\n\t${1:expression_a}\n\t${2:expression_b}\n\t${3:expression_c}\n)'), ('pair_Q\tFun', '(pair? ${1:pair_list})'), ('char_Q\tFun', '(char? ${1:char})'), ('char_cmp_Q\tFun', '(char-cmp? ${1:comparison_proc} ${2:char_a} ${3:char_b})'), ('char_ci_cmp_Q\tFun', '(char-ci-cmp? ${1:comparison_proc} ${2:char_a} ${3:char_b})'), ('char_equal_Q\tFun', '(char=? ${1:char_a} ${2:char_b})'), ('char_less_than_Q\tFun', '(char<? ${1:char_a} ${2:char_b})'), ('char_greater_than_Q\tFun', '(char>? ${1:char_a} ${2:char_b})'), ('char_less_than_equal_Q\tFun', '(char<=? ${1:char_a} ${2:char_b})'), ('char_greater_than_equal_Q\tFun', '(char>=? ${1:char_a} ${2:char_b})'), ('char_ci_equal_Q\tFun', '(char-ci=? ${1:char_a} ${2:char_b})'), ('char_ci_less_than_Q\tFun', '(char-ci<? ${1:char_a} ${2:char_b})'), ('char_ci_greater_than_Q\tFun', '(char-ci>? ${1:char_a} ${2:char_b})'), ('char_ci_less_than_equal_Q\tFun', '(char-ci<=? ${1:char_a} ${2:char_b})'), ('char_ci_greater_than_equal_Q\tFun', '(char-ci>=? ${1:char_a} ${2:char_b})'), ('string_cmp_Q\tFun', '(string-cmp? ${1:char-cmp} ${2:comparison_proc} ${3:string_a} ${4:string_b})'), ('string_cmp_Q_block\tFun', '(string-cmp?\n\t${1:char-cmp}\n\t${2:comparison_proc}\n\t${3:string_a}\n\t${4:string_b}\n)'), ('char_to_integer\tFun', '(char->integer ${1:char})'), ('integer_to_char\tFun', '(integer->char ${1:integer})'), ('atom_Q\tFun', '(atom? ${1:expression})'), ('atom_to_string\tFun', '(atom->string ${1:atom})'), ('string\tFun', '(string ${1:char_a} ${2:char_b} ${3:char_n})'), ('string_Q\tFun', '(string? ${1:string})'), ('string_length\tFun', '(string-length ${1:string})'), ('string_to_number\tFun', '(string->number ${1:string})'), ('string_to_atom\tFun', '(string->atom ${1:string})'), ('string_anyatom\tFun', '(string->anyatom ${1:string} ${2:proc})'), ('anyatom_string\tFun', '(anyatom->string ${1:atom} ${2:proc})'), ('string_append\tFun', '(string-append ${1:string_a} ${2:string_b})'), ('string_append_block\tFun', '(string-append\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_equal_Q\tFun', '(string=? ${1:string_a} ${2:string_b})'), ('string_equal_Q_block\tFun', '(string=?\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_less_than_Q\tFun', '(string<? ${1:string_a} ${2:string_b})'), ('string_greater_than_Q\tFun', '(string>? ${1:string_a} ${2:string_b})'), ('string_less_than_equal_Q\tFun', '(string<=? ${1:string_a} ${2:string_b})'), ('string_greater_than_equal_Q\tFun', '(string>=? ${1:string_a} ${2:string_b})'), ('string_ci_equal_Q\tFun', '(string-ci=? ${1:string_a} ${2:string_b})'), ('string_ci_equal_Q_block\tFun', '(string-ci=?\n\t${1:string_a}\n\t${2:string_b}\n)'), ('string_ci_less_than_Q\tFun', '(string-ci<? ${1:string_a} ${2:string_b})'), ('string_ci_greater_than_Q\tFun', '(string-ci>? ${1:string_a} ${2:string_b})'), ('string_ci_less_than_equal_Q\tFun', '(string-ci<=? ${1:string_a} ${2:string_b})'), ('string_ci_greater_than_equal_Q\tFun', '(string-ci>=? ${1:string_a} ${2:string_b})'), ('symbol_to_string\tFun', '(symbol->string ${1:symbol})'), ('string_to_symbol\tFun', '(string->symbol ${1:string})'), ('string_to_list\tFun', '(string->list ${1:string})'), ('string_set\tFun', '(string-set! ${1:variable_mutable_str} ${2:index} ${3:char})'), ('make_string\tFun', '(make-string ${1:length_number} ${2:char_OPTIONAL})'), ('string_copy\tFun', '(string-copy ${1:variable_or_str})'), ('string_fill\tFun', '(string-fill! ${1:variable_mutable_str} ${2:char})'), ('string_ref\tFun', '(string-ref ${1:string} ${2:index})'), ('substring\tFun', '(substring ${1:string} ${2:start_index} ${3:end_index})'), ('symbol_Q\tFun', '(symbol? ${1:symbol})'), ('list_Q\tFun', '(list? ${1:list})'), ('list_reference\tFun', '(list-ref ${1:list} ${2:index})'), ('length\tFun', '(length ${1:list})'), ('list_tail\tFun', '(list-tail ${1:list} ${2:no_of_elements_tobe_removed_from_head})'), ('last_pair\tFun', '(last-pair ${1:list})'), ('reverse\tFun', '(reverse ${1:list})'), ('list_to_string\tFun', '(list->string ${1:list})'), ('list_to_vector\tFun', '(list->vector ${1:list})'), ('member\tFun', '(member ${1:element} ${2:list})'), ('memq\tFun', '(memq ${1:element} ${2:list})'), ('memv\tFun', '(memv ${1:element} ${2:list})'), ('generic_member\tFun', '(generic-member ${1:comparison_proc} ${2:element} ${3:list})'), ('generic_member_block\tFun', '(generic-member\n\t${1:comparison_proc}\n\t${2:element}\n\t${3:list}\n)'), ('assoc\tFun', '(assoc ${1:element} ${2:list_of_pairs})'), ('assq\tFun', '(assq ${1:element} ${2:list_of_pairs})'), ('assv\tFun', '(assv ${1:element} ${2:list_of_pairs})'), ('generic_assoc\tFun', '(generic-assoc ${1:comparison_proc} ${2:element} ${3:list_of_pairs})'), ('generic_assoc_block\tFun', '(generic-assoc\n\t${1:comparison_proc}\n\t${2:element}\n\t${3:list_of_pairs}\n)'), ('map\tFun', '(map ${1:proc} ${2:list})'), ('map_block\tFun', '(map\n\t${1:proc}\n\t${2:list}\n)'), ('apply\tFun', '(apply ${1:proc} ${2:list})'), ('apply_block\tFun', '(apply\n\t${1:proc}\n\t${2:list}\n)'), ('for_each\tFun', '(for-each ${1:proc} ${2:list})'), ('for_each_block\tFun', '(for-each\n\t${1:proc}\n\t${2:list}\n)'), ('begin\tFun', '(begin ${1:expression_a} ${2:expression_b} ${3:expression_n})'), ('begin_block\tFun', '(begin\n\t${1:expressions}\n)'), ('eq_Q\tFun', '(eq? ${1:expression_a} ${2:expression_b})'), ('eqv_Q\tFun', '(eqv? ${1:expression_a} ${2:expression_b})'), ('equal_Q\tFun', '(equal? ${1:expression_a} ${2:expression_b})'), ('and\tFun', '(and ${1:expression_a} ${2:expression_b})'), ('and_block\tFun', '(and\n\t${1:expression_a}\n\t${2:expression_b}\n)'), ('or\tFun', '(or ${1:expression_a} ${2:expression_b})'), ('or_block\tFun', '(or\n\t${1:expression_a}\n\t${2:expression_b}\n)'), ('equal\tFun', '(= ${1:number_a} ${2:number_b})'), ('equal_block\tFun', '(=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('not_equal\tFun', '(<> ${1:number_a} ${2:number_b})'), ('not_equal_block\tFun', '(<>\n\t${1:number_a}\n\t${2:number_b}\n)'), ('less\tFun', '(< ${1:number_a} ${2:number_b})'), ('less_block\tFun', '(<\n\t${1:number_a}\n\t${2:number_b}\n)'), ('less_than_equal\tFun', '(<= ${1:number_a} ${2:number_b})'), ('less_than_equal_block\tFun', '(<=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('greater\tFun', '(> ${1:number_a} ${2:number_b})'), ('greater_block\tFun', '(>\n\t${1:number_a}\n\t${2:number_b}\n)'), ('greater_than_equal\tFun', '(>= ${1:number_a} ${2:number_b})'), ('greater_than_equal_block\tFun', '(>=\n\t${1:number_a}\n\t${2:number_b}\n)'), ('plus\tFun', '(+ ${1:number_a} ${2:number_b})'), ('minus\tFun', '(- ${1:big_number_a} ${2:small_number_b})'), ('multiply\tFun', '(* ${1:number_a} ${2:number_b})'), ('devide\tFun', '(/ ${1:number_a} ${2:number_b})'), ('zero_Q\tFun', '(zero? ${1:number})'), ('integer_Q\tFun', '(integer? ${1:number})'), ('exact_Q\tFun', '(exact? ${1:number})'), ('inexact_Q\tFun', '(inexact? ${1:number})'), ('complex_Q\tFun', '(complex? ${1:number})'), ('number_Q\tFun', '(number? ${1:number})'), ('rational_Q\tFun', '(rational? ${1:number})'), ('real_Q\tFun', '(real? ${1:number})'), ('even_Q\tFun', '(even? ${1:number})'), ('odd_Q\tFun', '(odd? ${1:number})'), ('positive_Q\tFun', '(positive? ${1:number})'), ('negative_Q\tFun', '(negative? ${1:number})'), ('succ\tFun', '(succ ${1:number})'), ('pred\tFun', '(pred ${1:number})'), ('abs\tFun', '(abs ${1:number})'), ('exact_to_inexact\tFun', '(exact->inexact ${1:number})'), ('inexact_to_exact\tFun', '(inexact->exact ${1:number})'), ('exp\tFun', '(exp ${1:number})'), ('expt\tFun', '(expt ${1:number_base} ${2:number_exponent})'), ('sqrt\tFun', '(sqrt ${1:number})'), ('log\tFun', '(log ${1:number})'), ('sin\tFun', '(sin ${1:number})'), ('cos\tFun', '(cos ${1:number})'), ('tan\tFun', '(tan ${1:number})'), ('asin\tFun', '(asin ${1:number})'), ('acos\tFun', '(acos ${1:number})'), ('atan\tFun', '(atan ${1:number})'), ('round\tFun', '(round ${1:number})'), ('floor\tFun', '(floor ${1:number})'), ('ceiling\tFun', '(ceiling ${1:number})'), ('trunc\tFun', '(trunc ${1:number})'), ('quotient\tFun', '(quotient ${1:number_a} ${2:number_b})'), ('remainder\tFun', '(remainder ${1:number_a} ${2:number_b})'), ('modulo\tFun', '(modulo ${1:number_a} ${2:number_b})'), ('gcd\tFun', '(gcd ${1:number_a} ${2:number_b})'), ('lcm\tFun', '(lcm ${1:number_a} ${2:number_b} ${3:number_n})'), ('max\tFun', '(max ${1:number_a} ${2:number_b} ${3:number_n})'), ('min\tFun', '(min ${1:number_a} ${2:number_b} ${3:number_n})'), ('unzip1_with_cdr\tFun', '(unzip1-with-cdr ${1:list_a} ${2:list_b} ${3:list_n})'), ('unzip1_with_cdr_iterative\tFun', '(unzip1-with-cdr-iterative ${1:multiple_lists} ${2:cars} ${3:cdrs})'), ('head\tFun', '(head ${1:stream})'), ('tail\tFun', '(tail ${1:stream})'), ('shared_tail\tFun', '(shared-tail ${1:list_a} ${2:list_b})'), ('eval\tFun', '(eval ${1:expression} ${2:environment_OPTIONAL})'), ('make_environment\tFun', '(make-environment ${1:expression})'), ('current_environment\tFun', '(current-environment)'), ('call_with_current_continuation\tFun', '(call-with-current-continuation ${1:proc})'), ('call_cc\tFun', '(call/c ${1:proc})'), ('define_with_return\tFun', '(define-with-return ${1:expression})'), ('define_with_return_block\tFun', '(define-with-return\n\t${1:expression}\n)'), ('random_next\tFun', '(random-next)'), ('cond_expand\tFun', '(cond-expand ${1:list})'), ('cond_expand_runtime\tFun', '(cond-expand-runtime ${1:list})'), ('cond_eval\tFun', '(cond-eval ${1:condition})'), ('cond_eval_and\tFun', '(cond-eval-and ${1:cond_list})'), ('cond_eval_or\tFun', '(cond-eval-or ${1:cond_list})'), ('eval_polymorphic\tFun', '(eval-polymorphic ${1:expressions})'), ('gensym\tFun', '(gensym)'), ('gc\tFun', '(gc)'), ('gc_verbose\tFun', '(gc-verbose ${1:bool})'), ('quit\tFun', '(quit ${1:number_OPTIONAL})'), ('tracing\tFun', '(tracing ${1:0_OFF_1_ON})'), ('boolean_Q\tFun', '(boolean? ${1:boolean})'), ('procedure_Q\tFun', '(procedure? ${1:proc})'), ('closure_Q\tFun', '(closure? ${1:proc})'), ('macro_Q\tFun', '(macro? ${1:expression})'), ('macro_expand\tFun', '(macro-expand ${1:macro_name_within_literal_list_with_args})'), ('macro\tFun', '(macro (${1:identifier} form) ${2:expression})'), ('macro_block\tFun', '(macro (${1:identifier} form)\n\t${2:expressions}\n)'), ('define_macro\tFun', '(define-macro ${1:expressions})'), ('define_macro_block\tFun', '(define-macro\n\t${1:expressions}\n)'), ('environment_Q\tFun', '(environment? ${1:expression})'), ('force\tFun', '(force ${1:list})'), ('dynamic_wind\tFun', '(dynamic-wind ${1:before} ${2:thunk} ${3:after})'), ('dynamic_wind_block\tFun', '(dynamic-wind\n\t${1:before}\n\t${2:thunk}\n\t${3:after}\n)'), ('oblist\tFun', '(oblist)'), ('new_segment\tFun', '(new-segment ${1:number})'), ('get_closure_code\tFun', '(get-closure-code ${1:closure_name})'), ('make_closure\tFun', '(make-closure ${1:code} ${2:environment})'), ('foldr\tFun', '(foldr ${1:proc} ${2:expression} ${3:list})'), ('foldr_block\tFun', '(foldr\n\t${1:proc}\n\t${2:expression}\n\t${3:list}\n)'), ('catch\tFun', '(catch ${1:expression_exception_raised} ${2:expression_exception_tested})'), ('catch_block\tFun', '(catch\n\t${1:expression_exception_raised}\n\t${2:expression_exception_tested}\n)'), ('throw\tFun', '(throw ${1:string})'), ('load\tFun', '(load ${1:path_scheme_script_string})'), ('list_literal\tFun', "'(${1:element_a} ${2:element_b} ${3:element_n})"), ('vector_literal\tFun', '#(${1:element_a} ${2:element_b} ${3:element_n})'), ('block\tFun', '(\n\t${1:expression}\n)'), ('test_block\tFun', '(${1:test}\n\t${2:expression}\n)'), ('one_liner\tFun', '(${1:expression})'), ('list\tFun', '(list ${1:element_a} ${2:element_b} ${3:element_n})')]

class TinySchemeAutoComplete(sublime_plugin.EventListener):

  def on_query_completions(self, view, prefix, locations):
    return PROCS if view.match_selector(locations[0], 'source.lisp - string - comment') else None

# Copyright (c) 2020 civAnimal ... Email: civanimal@gmail.com ... Twitter: civAnimal
# Released under ... GNU General Public License (v3)
